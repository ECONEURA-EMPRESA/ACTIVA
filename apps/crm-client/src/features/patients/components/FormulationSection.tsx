import React, { useState, useCallback } from 'react';
import { CheckSquare, Save } from 'lucide-react';
import { Button } from '../../../components/ui/Button';
import { FORMULATION_OPTIONS, PATHOLOGY_MAP } from '../../../lib/patientUtils';
import { ClinicalFormulation, FormulationData, Patient } from '../../../lib/types';

interface FormulationSectionProps {
    title: string;
    optionsKey: keyof typeof FORMULATION_OPTIONS;
    fieldKey: keyof ClinicalFormulation;
    initialData: FormulationData | string | undefined;
    onSave: (fieldKey: keyof ClinicalFormulation, data: FormulationData) => void;
    patient: Patient; // REQUIRED: Was accessed from closure before
}

export const FormulationSection: React.FC<FormulationSectionProps> = ({ title, optionsKey, fieldKey, initialData, onSave, patient }) => {
    const isFormulationData = useCallback((val: unknown): val is FormulationData => {
        return typeof val === 'object' && val !== null && 'selected' in val;
    }, []);

    const normalizeData = useCallback((val: unknown): FormulationData => {
        return isFormulationData(val)
            ? val
            : { selected: [], text: typeof val === 'string' ? val : '' };
    }, [isFormulationData]);

    const computeInitialData = useCallback(() => {
        const data = normalizeData(initialData);
        // Auto-template logic moved here
        if (!data.text && patient.diagnosis) {
            let template = '';
            if (fieldKey === 'synthesis') {
                template = `Paciente de ${patient.age} años con diagnóstico principal de ${patient.diagnosis}.` +
                    (patient.pathologyType ? ` Se clasifica dentro del espectro: ${PATHOLOGY_MAP[patient.pathologyType] || patient.pathologyType}.` : '');
            } else if (fieldKey === 'hypothesis') {
                template = `Se propone intervención musicoterapéutica centrada en ${patient.diagnosis.toLowerCase().includes('demencia') ? 'estimulación cognitiva y reminiscencia' : 'regulación emocional y expresión'}.`;
            } else if (fieldKey === 'objectives') {
                if (patient.diagnosis.toLowerCase().includes('alzheimer') || patient.diagnosis.toLowerCase().includes('demencia')) {
                    template = "1. Mantenimiento de funciones cognitivas (atención, memoria).\n2. Reducción de sintomatología conductual y ansiógena.\n3. Fomento de la conexión con el entorno y la identidad sonora.\n4. Estimulación de la memoria autobiográfica a través de la reminiscencia musical.";
                } else if (patient.age < 18) {
                    template = "1. Fomentar la expresión emocional y la comunicación no verbal.\n2. Mejorar la atención conjunta y la interacción social.\n3. Desarrollo de habilidades motrices y rítmicas.\n4. Regulación sensorial y conductual.";
                } else {
                    template = "1. Mejorar el bienestar emocional y la autopercepción.\n2. Facilitar la expresión de sentimientos bloqueados.\n3. Promover la relajación y reducción de estrés.\n4. Potenciar recursos creativos y de afrontamiento.";
                }
            }
            if (template) {
                return { ...data, text: template, isAutoGenerated: true };
            }
        }
        return data;
    }, [initialData, patient, fieldKey, normalizeData]);

    // Compute initial data synchronously (Lazy initialization logic)
    const initialComputed = computeInitialData();
    const [localData, setLocalData] = useState<FormulationData>(initialComputed);

    // Set dirty if it was auto-generated
    const [isDirty, setIsDirty] = useState((initialComputed as FormulationData & { isAutoGenerated?: boolean }).isAutoGenerated || false);

    const handleCheck = (option: string) => {
        const newSelected = localData.selected.includes(option)
            ? localData.selected.filter((s) => s !== option)
            : [...localData.selected, option];
        setLocalData({ ...localData, selected: newSelected });
        setIsDirty(true);
    };

    const handleText = (text: string) => {
        setLocalData({ ...localData, text });
        setIsDirty(true);
    };

    const handleSaveClick = () => {
        onSave(fieldKey, localData);
        setIsDirty(false);
    };

    return (
        <div className="bg-white p-5 rounded-xl shadow-sm border border-slate-200 flex flex-col h-full">
            <h4 className="font-bold text-slate-700 text-sm uppercase tracking-wide mb-3 flex items-center gap-2">
                <CheckSquare size={16} className="text-pink-600" /> {title}
            </h4>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-2 mb-4">
                {(FORMULATION_OPTIONS[optionsKey] || []).map((opt: string) => (
                    <label
                        key={opt}
                        className="flex items-start gap-2 text-sm text-slate-600 cursor-pointer hover:bg-slate-50 p-1.5 rounded transition-colors border border-transparent hover:border-slate-100"
                    >
                        <input
                            type="checkbox"
                            className="mt-0.5 accent-pink-600 w-4 h-4"
                            checked={localData.selected.includes(opt)}
                            onChange={() => handleCheck(opt)}
                        />
                        <span className="leading-snug select-none">{opt}</span>
                    </label>
                ))}
            </div>
            <textarea
                className="input-pro text-sm h-32 resize-none bg-slate-50 border-slate-200 focus:bg-white mb-4"
                placeholder="Detalles clínicos y observaciones..."
                value={localData.text}
                onChange={(e) => handleText(e.target.value)}
            />
            <div className="mt-auto flex justify-end">
                <Button
                    size="sm"
                    variant={isDirty ? 'primary' : 'secondary'}
                    onClick={handleSaveClick}
                    icon={Save}
                    disabled={!isDirty}
                >
                    {isDirty ? 'Guardar Cambios' : 'Actualizado'}
                </Button>
            </div>
        </div>
    );
};
